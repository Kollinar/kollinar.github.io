<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Лабиринт</title>
 <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      background-color: #f5f5f5;
    }

    .container {
      display: flex;
      align-items: flex-start;
      gap: 20px; /* Расстояние между правилами и картой */
    }

    .rules {
      width: 200px;
      padding: 10px;
      border: 1px solid #ccc;
      background-color: white;
      border-radius: 5px;
      text-align: left;
    }

    .maze-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(18, 20px);
      gap: 2px;
    }

    .cell {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
    }

    .unknown { background-color: #888; }
    .wall { background-color: black; }
    .path { background-color: #ccc; }
    .visited { background-color: #999; }
    .player { background-color: red; }
    .exit { background-color: yellow; }
    .source { background-color: green; }

    .controls {
      display: flex;
      justify-content: space-between;
      width: 360px; /* Ширина равна ширине карты */
      margin-top: 10px;
    }

    .compass {
      display: grid;
      grid-template-rows: auto auto auto;
      grid-template-columns: auto auto auto;
      gap: 5px;
      justify-items: center;
    }

.controls button {
    appearance: none;
    background-color: transparent; /* Фон кнопки */
    border: 2px solid #e52727; /* Цвет границы */
    border-radius: 0.6em; /* Закругление углов */
    color: #e52727; /* Цвет текста (можно изменить здесь) */
    cursor: pointer;
    display: flex;
    align-items: center; /* Выравнивание по центру */
    justify-content: center; /* Выравнивание по центру */
    font-size: 0.6rem; /* Размер текста (уменьшен) */
    font-weight: 500; /* Жирность текста */
    line-height: 1;
    margin: 0px; /* Внешний отступ (уменьшен) */
    padding: 0.5em 1em; /* Внутренний отступ (уменьшен) */
    text-decoration: none;
    text-align: center;
    text-transform: uppercase;
    font-family: 'Montserrat', sans-serif;

    &:hover,
    &:focus {
        color: #fff; /* Цвет текста при наведении (можно изменить здесь) */
        outline: 0;
    }
}

.compass .north {
    grid-row: 1;
    grid-column: 2;
    transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
}

.compass .west {
    grid-row: 2;
    grid-column: 1;
    transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
}

.compass .east {
    grid-row: 2;
    grid-column: 3;
    transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
}

.compass .south {
    grid-row: 3;
    grid-column: 2;
    transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
}

    .actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
	  
    }
	
	.actions .markSource {

	      transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
    }
	
		.actions .markExit {
      display: flex;
      flex-direction: column;
      gap: 10px;
	      transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
    }
	
		.actions .resetGame {
      display: flex;
      flex-direction: column;
      gap: 10px;
	      transition: box-shadow 300ms ease-in-out, color 300ms ease-in-out;

    &:hover {
        box-shadow: 0 0 40px 40px #e52727 inset; /* Цвет тени при наведении (можно изменить здесь) */
    }
    }
	     /* Адаптация для мобильных устройств */
    @media (max-width: 600px) {
      /* Размер карты */
      .grid {
        width: 90vw; /* Карта занимает 90% ширины экрана */
        aspect-ratio: 1 / 1; /* Сохраняем квадратную форму */
      }

      .cell {
        width: calc(90vw / 18); /* Размер ячейки зависит от ширины экрана */
        height: calc(90vw / 18);
      }

      /* Убираем название и правила */
      h1 {
        display: none;
      }

      .rules {
        display: none;
      }

      /* Компактное расположение кнопок */
      .controls {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
      }

      button {
        font-size: 0.8rem;
        padding: 8px;
      }
	    		.compass {
			display: grid;
			grid-template-rows: auto auto auto;
			grid-template-columns: auto auto auto;
			gap: 5px;
			justify-items: center;
			width: 90vw
	    }
		
		
		.compass .north {
    grid-row: 1;
    grid-column: 2;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
}

.compass .west {
    grid-row: 2;
    grid-column: 1;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
}

.compass .east {
    grid-row: 2;
    grid-column: 3;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
}

.compass .south {
    grid-row: 3;
    grid-column: 2;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
}

    .actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
	  
    }
	    
    }
	 
  </style>
</head>
<body>
  <h1>Лабиринт</h1>
  <div class="container">
    <!-- Правила -->
    <div class="rules">
      <h3>Правила:</h3>
      <p></p>
      <ul>
        <li>Используйте кнопки "Север, Юг, Запад, Восток" или <B>стрелки клавиатуры</B> для перемещения как идете в лабиринте колодца, когда пройдете несколько клеток карта определит и покажет лабирит.</li>
        <li><B>Источник</B> отмечает на найденом лабиринте точку источника</li>
		<li><B>Выход</B> отмечает клетки предпологаемого выхода, что бы к ним можно было вернуться</li>
        <li>Сбросьте игру, что бы начать заного.</li>
      </ul>
    </div>

    <!-- Контейнер с картой и кнопками -->
    <div class="maze-container">
      <!-- Лабиринт -->
      <div id="maze" class="grid"></div>

      <!-- Кнопки управления -->
      <div class="controls">
        <!-- Компас -->
        <div class="compass">
          <button class="north" onclick="move(-1, 0)">Север</button>
          <button class="west" onclick="move(0, -1)">Запад</button>
          <button class="east" onclick="move(0, 1)">Восток</button>
          <button class="south" onclick="move(1, 0)">Юг</button>
        </div>

        <!-- Действия -->
        <div class="actions">
          <button class="markSource" onclick="markSource()">Источник</button>
          <button class="markExit" onclick="markExit()">Выход</button>
          <button class="resetGame" onclick="resetGame()">Сброс</button>
        </div>
      </div>
    </div>
  </div>
  <script>

  // Добавь свои лабиринты в mazeOptions (каждый 18x18 массив, 0 - проход, 1 - стена)
const mazeOptions = [
	        // Лабиринт 1
    [
		[1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1],
		[0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1],
		[1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0],
		[1,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,0],
		[0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0],
		[0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0],
		[0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0],
		[1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
		[1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,1,1],
		[1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0],
		[0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,0],
		[1,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,1],
		[1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0],
		[0,0,1,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0],
		[1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0],
		[0,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0],
		[0,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0]
     ],
    // Лабиринты 2
	[
		[0,0,0,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0],
		[0,1,0,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0],
		[1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0],
		[0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0],
		[0,0,0,1,1,0,0,1,1,1,0,1,0,1,0,0,1,0],
		[1,0,1,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0],
		[0,0,1,0,0,1,1,1,0,1,0,1,0,0,0,0,1,0],
		[1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0],
		[0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0],
		[0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0],
		[0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0],
		[1,0,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1],
		[1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0],
		[0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,0,0],
		[1,1,1,0,1,1,0,1,0,0,1,0,1,1,1,0,1,1],
		[1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0],
		[0,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1,0,1],
		[1,0,0,1,0,1,1,0,1,0,0,0,0,1,1,1,0,0]
	],
		//Лабиринт 3
	[
		[1,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0],
		[1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0],
		[0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1],
		[1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0],
		[1,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1],
		[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0],
		[0,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0],
		[0,0,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,0],
		[0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1],
		[0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1],
		[1,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0],
		[0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1],
		[0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1],
		[0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],
		[0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,1,0,0],
		[1,0,1,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1],
		[0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0]
	],
	//Лабиринт 4
	[
		[1,1,1,0,0,1,0,1,1,0,1,1,0,0,1,0,1,0],
		[1,0,1,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0],
		[0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,1],
		[1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0],
		[1,0,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],
		[0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0,0,1],
		[0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0],
		[0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,1],
		[1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,0,0],
		[1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1],
		[0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1],
		[0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
		[1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0],
		[0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1],
		[1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0],
		[0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,0,1,0]
	],
	//Лабиринт 5
	[
		[0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0],
		[1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,1,1,0],
		[0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0],
		[0,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,0],
		[0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
		[0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,0,0,0],
		[1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0],
		[0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,0],
		[1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1],
		[0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0],
		[0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0],
		[0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0],
		[1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1],
		[0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1],
		[0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0],
		[1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,1,1],
		[0,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1]
	]
    ];

// Добавляем обработчик клавиш
document.addEventListener("keydown", handleKeyPress);

function handleKeyPress(event) {
    // Получаем код нажатой клавиши
    switch (event.key) {
        case "ArrowUp": // Стрелка вверх
            move(-1, 0); // Движение на север
            break;
        case "ArrowDown": // Стрелка вниз
            move(1, 0); // Движение на юг
            break;
        case "ArrowLeft": // Стрелка влево
            move(0, -1); // Движение на запад
            break;
        case "ArrowRight": // Стрелка вправо
            move(0, 1); // Движение на восток
            break;
        default:
            // Если нажата другая клавиша, ничего не делаем
            break;
    }
}
	  
let maze = [];
let playerMoves = []; // запоминаем движения в виде [dx, dy]
let cumulativePath = [[9, 9]]; // Начальная точка установлена в центр карты (9,9)
let matchedMaze = null;
let labyrinthStartCandidate = null; // найденная начальная позиция на лабиринте
let sourcePosition = null; // Глобальная переменная для хранения позиции источника

function initMaze() {
	maze = [];
	sourcePosition = null; // Сбрасываем позицию источника    
    maze = Array(18).fill().map(() => Array(18).fill(0)); // Инициализация пустой карты
    playerMoves = []; //очищение масива движений игрока   
    cumulativePath = [[9, 9]]; // Устанавливаем начальную точку в центр карты (9,9)
    matchedMaze = null; // Сбрасываем найденый лбиринт
    labyrinthStartCandidate = null;
    render(); //рендер карты
}


function move(dx, dy) {
    let curr = cumulativePath[cumulativePath.length - 1];
    let next = [curr[0] + dx, curr[1] + dy];

    // Проверка для режима с найденным лабиринтом
    if (matchedMaze && labyrinthStartCandidate) {
        const absX = labyrinthStartCandidate[0] + (next[0] - 9);
        const absY = labyrinthStartCandidate[1] + (next[1] - 9);

        if (absX < 0 || absX >= 18 || absY < 0 || absY >= 18 || matchedMaze[absX][absY] === 1) {
            return;
        }
    } 
    // Проверка для режима исследования (пустая карта)
    else {
        if (next[0] < 0 || next[0] >= 18 || next[1] < 0 || next[1] >= 18) {
            return;
        }
    }

    playerMoves.push([dx, dy]);
    cumulativePath.push(next);
    checkMatch();
    render();
}

function checkMatch() {
    if (matchedMaze) return;
    const candidates = [];

    mazeOptions.forEach(option => {
        for (let i = 0; i < 18; i++) {
            for (let j = 0; j < 18; j++) {
                let valid = true;
                
                for (const [dx, dy] of cumulativePath) {
                    // Корректируем координаты относительно центра
                    const x = i + (dx - 9);
                    const y = j + (dy - 9);
                    
                    if (x < 0 || x >= 18 || 
                        y < 0 || y >= 18 || 
                        option[x][y] !== 0) {
                        valid = false;
                        break;
                    }
                }
                
                if (valid) candidates.push({ maze: option, start: [i, j] });
            }
        }
    });

	if (candidates.length === 1) {
		matchedMaze = JSON.parse(JSON.stringify(candidates[0].maze)); // Создаем новую копию
		labyrinthStartCandidate = candidates[0].start;
		render();
	}
}

function markExit() {
    if (!matchedMaze || !labyrinthStartCandidate) return;
    
    let last = cumulativePath[cumulativePath.length - 1];
    let absPos = [
        labyrinthStartCandidate[0] + (last[0] - 9),
        labyrinthStartCandidate[1] + (last[1] - 9)
    ];
    
    if (absPos[0] >= 0 && absPos[0] < 18 && absPos[1] >= 0 && absPos[1] < 18) {
        const directions = [
            [-1, 0], [1, 0], [0, -1], [0, 1]
        ];
        
        directions.forEach(([dx, dy]) => {
            const nx = absPos[0] + dx;
            const ny = absPos[1] + dy;
            
            if (nx >= 0 && nx < 18 && ny >= 0 && ny < 18 &&
                matchedMaze[nx][ny] === 0 &&
                !cumulativePath.some(([px, py]) => 
                    px - 9 === nx - labyrinthStartCandidate[0] &&
                    py - 9 === ny - labyrinthStartCandidate[1])) {
                matchedMaze[nx][ny] = 2;
            }
        });
        
        render();
    }
}

function markSource() {
    if (!matchedMaze || !labyrinthStartCandidate) return;
    
    let last = cumulativePath[cumulativePath.length - 1];
    let absPos = [
        labyrinthStartCandidate[0] + (last[0] - 9),
        labyrinthStartCandidate[1] + (last[1] - 9)
    ];
    
    // Проверяем, что позиция внутри карты
    if (absPos[0] >= 0 && absPos[0] < 18 && absPos[1] >= 0 && absPos[1] < 18) {
        // Устанавливаем источник только если ячейка является проходом
        if (matchedMaze[absPos[0]][absPos[1]] === 0) {
            matchedMaze[absPos[0]][absPos[1]] = 3; // Отмечаем как источник
            sourcePosition = [absPos[0], absPos[1]]; // Сохраняем позицию
            render();
        }
    }
}

function resetGame() {
    initMaze();
}

function render() {
    const mazeEl = document.getElementById("maze");

    // Если сетка еще не создана, создаем её
    if (mazeEl.children.length === 0) {
        for (let i = 0; i < 18; i++) {
            for (let j = 0; j < 18; j++) {
                let div = document.createElement("div");
                div.className = "cell unknown";
                mazeEl.appendChild(div);
            }
        }
    }

    // Проходим по всем ячейкам и обновляем их классы
    for (let i = 0; i < 18; i++) {
        for (let j = 0; j < 18; j++) {
            let cell = mazeEl.children[i * 18 + j]; // Получаем существующую ячейку

            // Обновляем классы в зависимости от текущего состояния
            if (matchedMaze && labyrinthStartCandidate) {
                switch (matchedMaze[i][j]) {
                    case 1:
                        cell.className = "cell wall"; // Стена
                        break;
                    case 2:
                        cell.className = "cell exit"; // Выход
                        break;
                    case 3:
                        cell.className = "cell source"; // Источник
                        break;
                    default:
                        cell.className = "cell path"; // Путь
                }
            } else {
                cell.className = "cell unknown"; // Неизвестная клетка
            }
        }
    }

    // Отрисовываем пройденный путь
    cumulativePath.forEach(([dx, dy]) => {
        if (matchedMaze && labyrinthStartCandidate) {
            let x = labyrinthStartCandidate[0] + (dx - 9);
            let y = labyrinthStartCandidate[1] + (dy - 9);

            if (x >= 0 && x < 18 && y >= 0 && y < 18) {
                // Проверяем, чтобы не перекрыть источник
                if (!(sourcePosition && x === sourcePosition[0] && y === sourcePosition[1])) {
                    mazeEl.children[x * 18 + y].className = "cell visited";
                }
            }
        } else {
            // Режим пустой карты
            if (dx >= 0 && dx < 18 && dy >= 0 && dy < 18) {
                mazeEl.children[dx * 18 + dy].className = "cell visited";
            }
        }
    });

    // Отрисовываем текущее положение игрока
    let last = cumulativePath[cumulativePath.length - 1];
    if (matchedMaze && labyrinthStartCandidate) {
        let px = labyrinthStartCandidate[0] + (last[0] - 9);
        let py = labyrinthStartCandidate[1] + (last[1] - 9);

        if (px >= 0 && px < 18 && py >= 0 && py < 18) {
            mazeEl.children[px * 18 + py].className = "cell player";
        }
    } else {
        // Режим пустой карты
        let px = last[0], py = last[1];

        if (px >= 0 && px < 18 && py >= 0 && py < 18) {
            mazeEl.children[px * 18 + py].className = "cell player";
        }
    }
}

initMaze();

  </script>

</body>
</html>
