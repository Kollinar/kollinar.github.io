<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Лабиринт 18x18</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      background-color: #f5f5f5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(18, 20px);
      gap: 2px;
      margin-bottom: 1rem;
    }
    .cell {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
    }
    .unknown { background-color: #888; }
    .wall { background-color: black; }
    .path { background-color: #ccc; }
    .visited { background-color: #999; }
    .player { background-color: red; }
    .exit { background-color: yellow; }
    .source { background-color: green; }
    button { margin: 5px; }
  </style>
</head>
<body>
  <h1>Лабиринт</h1>
  <div id="maze" class="grid"></div>
  
  <div>
    <button onclick="move(-1, 0)">Север</button>
    <button onclick="move(1, 0)">Юг</button>
    <button onclick="move(0, -1)">Запад</button>
    <button onclick="move(0, 1)">Восток</button>
  </div>
  
  <div>
    <button onclick="markExit()">Обозначить выход</button>
    <button onclick="markSource()">Источник</button>
    <button onclick="resetGame()">Сброс</button>
  </div>
  
  <script>

  // Добавь свои лабиринты в mazeOptions (каждый 18x18 массив, 0 - проход, 1 - стена)
const mazeOptions = [
	        // Лабиринт 1
    [
		[1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1],
		[0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1],
		[1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0],
		[1,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,0],
		[0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0],
		[0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0],
		[0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0],
		[1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
		[1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,1,1],
		[1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0],
		[0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,0],
		[1,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,1],
		[1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0],
		[0,0,1,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0],
		[1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0],
		[0,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0],
		[0,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0]
     ],
    // Лабиринты 2
	[
		[0,0,0,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0],
		[0,1,0,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0],
		[1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0],
		[0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0],
		[0,0,0,1,1,0,0,1,1,1,0,1,0,1,0,0,1,0],
		[1,0,1,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0],
		[0,0,1,0,0,1,1,1,0,1,0,1,0,0,0,0,1,0],
		[1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0],
		[0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0],
		[0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0],
		[0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0],
		[1,0,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1],
		[1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0],
		[0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,0,0],
		[1,1,1,0,1,1,0,1,0,0,1,0,1,1,1,0,1,1],
		[1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0],
		[0,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1,0,1],
		[1,0,0,1,0,1,1,0,1,0,0,0,0,1,1,1,0,0]
	],
		//Лабиринт 3
	[
		[1,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,0,0],
		[1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0],
		[0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1],
		[1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0],
		[1,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1],
		[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0],
		[0,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0],
		[0,0,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,0],
		[0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1],
		[0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1],
		[1,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0],
		[0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1],
		[0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1],
		[0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],
		[0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,1,0,0],
		[1,0,1,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1],
		[0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0]
	],
	//Лабиринт 4
	[
		[1,1,1,0,0,1,0,1,1,0,1,1,0,0,1,0,1,0],
		[1,0,1,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0],
		[0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,1],
		[1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0],
		[1,0,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],
		[0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0,0,1],
		[0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0],
		[0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,1],
		[1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,0,0],
		[1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1],
		[0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1],
		[0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
		[1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0],
		[0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1],
		[1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0],
		[0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,0,1,0]
	],
	//Лабиринт 5
	[
		[0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0],
		[1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,1,1,0],
		[0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0],
		[0,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,0],
		[0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
		[0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,0,0,0],
		[1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0],
		[0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,0],
		[1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1],
		[0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0],
		[0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0],
		[0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0],
		[1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1],
		[0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1],
		[0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0],
		[1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,1,1],
		[0,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1]
	]
    ];

let maze = [];
let playerMoves = []; // запоминаем движения в виде [dx, dy]
let cumulativePath = [[9, 9]]; // Начальная точка установлена в центр карты (9,9)
let matchedMaze = null;
let labyrinthStartCandidate = null; // найденная начальная позиция на лабиринте
let sourcePosition = null; // Глобальная переменная для хранения позиции источника

function initMaze() {
	maze = [];
	sourcePosition = null; // Сбрасываем позицию источника    
    maze = Array(18).fill().map(() => Array(18).fill(0)); // Инициализация пустой карты
    playerMoves = []; //очищение масива движений игрока   
    cumulativePath = [[9, 9]]; // Устанавливаем начальную точку в центр карты (9,9)
    matchedMaze = null; // Сбрасываем найденый лбиринт
    labyrinthStartCandidate = null;
    render(); //рендер карты
}


function move(dx, dy) {
    let curr = cumulativePath[cumulativePath.length - 1];
    let next = [curr[0] + dx, curr[1] + dy];

    // Проверка для режима с найденным лабиринтом
    if (matchedMaze && labyrinthStartCandidate) {
        const absX = labyrinthStartCandidate[0] + (next[0] - 9);
        const absY = labyrinthStartCandidate[1] + (next[1] - 9);

        if (absX < 0 || absX >= 18 || absY < 0 || absY >= 18 || matchedMaze[absX][absY] === 1) {
            return;
        }
    } 
    // Проверка для режима исследования (пустая карта)
    else {
        if (next[0] < 0 || next[0] >= 18 || next[1] < 0 || next[1] >= 18) {
            return;
        }
    }

    playerMoves.push([dx, dy]);
    cumulativePath.push(next);
    checkMatch();
    render();
}

function checkMatch() {
    if (matchedMaze) return;
    const candidates = [];

    mazeOptions.forEach(option => {
        for (let i = 0; i < 18; i++) {
            for (let j = 0; j < 18; j++) {
                let valid = true;
                
                for (const [dx, dy] of cumulativePath) {
                    // Корректируем координаты относительно центра
                    const x = i + (dx - 9);
                    const y = j + (dy - 9);
                    
                    if (x < 0 || x >= 18 || 
                        y < 0 || y >= 18 || 
                        option[x][y] !== 0) {
                        valid = false;
                        break;
                    }
                }
                
                if (valid) candidates.push({ maze: option, start: [i, j] });
            }
        }
    });

	if (candidates.length === 1) {
		matchedMaze = JSON.parse(JSON.stringify(candidates[0].maze)); // Создаем новую копию
		labyrinthStartCandidate = candidates[0].start;
		render();
	}
}

function markExit() {
    if (!matchedMaze || !labyrinthStartCandidate) return;
    
    let last = cumulativePath[cumulativePath.length - 1];
    let absPos = [
        labyrinthStartCandidate[0] + (last[0] - 9),
        labyrinthStartCandidate[1] + (last[1] - 9)
    ];
    
    if (absPos[0] >= 0 && absPos[0] < 18 && absPos[1] >= 0 && absPos[1] < 18) {
        const directions = [
            [-1, 0], [1, 0], [0, -1], [0, 1]
        ];
        
        directions.forEach(([dx, dy]) => {
            const nx = absPos[0] + dx;
            const ny = absPos[1] + dy;
            
            if (nx >= 0 && nx < 18 && ny >= 0 && ny < 18 &&
                matchedMaze[nx][ny] === 0 &&
                !cumulativePath.some(([px, py]) => 
                    px - 9 === nx - labyrinthStartCandidate[0] &&
                    py - 9 === ny - labyrinthStartCandidate[1])) {
                matchedMaze[nx][ny] = 2;
            }
        });
        
        render();
    }
}

function markSource() {
    if (!matchedMaze || !labyrinthStartCandidate) return;
    
    let last = cumulativePath[cumulativePath.length - 1];
    let absPos = [
        labyrinthStartCandidate[0] + (last[0] - 9),
        labyrinthStartCandidate[1] + (last[1] - 9)
    ];
    
    // Проверяем, что позиция внутри карты
    if (absPos[0] >= 0 && absPos[0] < 18 && absPos[1] >= 0 && absPos[1] < 18) {
        // Устанавливаем источник только если ячейка является проходом
        if (matchedMaze[absPos[0]][absPos[1]] === 0) {
            matchedMaze[absPos[0]][absPos[1]] = 3; // Отмечаем как источник
            sourcePosition = [absPos[0], absPos[1]]; // Сохраняем позицию
            render();
        }
    }
}

function resetGame() {
    initMaze();
}

function render() {
    const mazeEl = document.getElementById("maze");

    // Если сетка еще не создана, создаем её
    if (mazeEl.children.length === 0) {
        for (let i = 0; i < 18; i++) {
            for (let j = 0; j < 18; j++) {
                let div = document.createElement("div");
                div.className = "cell unknown";
                mazeEl.appendChild(div);
            }
        }
    }

    // Проходим по всем ячейкам и обновляем их классы
    for (let i = 0; i < 18; i++) {
        for (let j = 0; j < 18; j++) {
            let cell = mazeEl.children[i * 18 + j]; // Получаем существующую ячейку

            // Обновляем классы в зависимости от текущего состояния
            if (matchedMaze && labyrinthStartCandidate) {
                switch (matchedMaze[i][j]) {
                    case 1:
                        cell.className = "cell wall"; // Стена
                        break;
                    case 2:
                        cell.className = "cell exit"; // Выход
                        break;
                    case 3:
                        cell.className = "cell source"; // Источник
                        break;
                    default:
                        cell.className = "cell path"; // Путь
                }
            } else {
                cell.className = "cell unknown"; // Неизвестная клетка
            }
        }
    }

    // Отрисовываем пройденный путь
    cumulativePath.forEach(([dx, dy]) => {
        if (matchedMaze && labyrinthStartCandidate) {
            let x = labyrinthStartCandidate[0] + (dx - 9);
            let y = labyrinthStartCandidate[1] + (dy - 9);

            if (x >= 0 && x < 18 && y >= 0 && y < 18) {
                // Проверяем, чтобы не перекрыть источник
                if (!(sourcePosition && x === sourcePosition[0] && y === sourcePosition[1])) {
                    mazeEl.children[x * 18 + y].className = "cell visited";
                }
            }
        } else {
            // Режим пустой карты
            if (dx >= 0 && dx < 18 && dy >= 0 && dy < 18) {
                mazeEl.children[dx * 18 + dy].className = "cell visited";
            }
        }
    });

    // Отрисовываем текущее положение игрока
    let last = cumulativePath[cumulativePath.length - 1];
    if (matchedMaze && labyrinthStartCandidate) {
        let px = labyrinthStartCandidate[0] + (last[0] - 9);
        let py = labyrinthStartCandidate[1] + (last[1] - 9);

        if (px >= 0 && px < 18 && py >= 0 && py < 18) {
            mazeEl.children[px * 18 + py].className = "cell player";
        }
    } else {
        // Режим пустой карты
        let px = last[0], py = last[1];

        if (px >= 0 && px < 18 && py >= 0 && py < 18) {
            mazeEl.children[px * 18 + py].className = "cell player";
        }
    }
}

initMaze();

  </script>

</body>
</html>
